import re

#from django_rdkit import models
from django.db import models
from model_utils import Choices
from sequences import Sequence
from django.core.validators import RegexValidator

from django.contrib.postgres.fields import ArrayField
from django.core.validators import MaxValueValidator, MinValueValidator 
from django.db import transaction, IntegrityError
from django.utils.text import slugify

from apputil.models import AuditModel, Dictionary, ApplicationUser, Document
from dchem.models import Chem_Structure
from adjcoadd.constants import *

#-------------------------------------------------------------------------------------------------
# Screening Application Model
#-------------------------------------------------------------------------------------------------

#-------------------------------------------------------------------------------------------------
class Screen_Run(AuditModel):
    """
    List of Screening runs
    """
#-------------------------------------------------------------------------------------------------
    HEADER_FIELDS = {
        "run_id":"Run ID",
        "run_type":"Run Type",
        "assay_note":"Assay",
        "run_status":"Status",
        "run_project":"Project",
        "run_name":"Name",
        "run_date":"Run Date",
        "run_conditions":"Conditions",
        "run_issues":"Issues",
    }

    Choice_Dictionary = {
        'run_type':'Run_Type',
        'run_status':'Run_Status',
    }

    run_id = models.CharField(max_length=15,primary_key=True, verbose_name = "Run ID")
    run_name = models.CharField(max_length=500, verbose_name = "Run Name")
    run_type = models.ForeignKey(Dictionary, null=True, blank=True, verbose_name = "Run Type", on_delete=models.DO_NOTHING,
        db_column="run_type", related_name="%(class)s_RunType+")
    assay_note = models.CharField(max_length=250, blank=True, verbose_name = "Assay Note")
    run_conditions = models.CharField(max_length=250, blank=True, verbose_name = "Run Conditions")
    run_issues = models.CharField(max_length=250, blank=True, verbose_name = "Run Issues")
    run_date = models.DateField(null=True, blank=True, verbose_name = "Run Date")
    run_project = models.CharField(max_length=50, verbose_name = "Project")
    run_status = models.ForeignKey(Dictionary, null=True, blank=True, verbose_name = "Run Status", on_delete=models.DO_NOTHING,
        db_column="run_status", related_name="%(class)s_run_status+")
    
    # Summary Data -  to be generated by self.update_summary()
    # n_compounds = models.SmallIntegerField(default=0, verbose_name = "#Cpmds")
    # n_qc = models.SmallIntegerField(default=0, verbose_name = "#QC")
    # n_structure = models.SmallIntegerField(default=0, verbose_name = "#Struc")
    # n_motherplates = models.SmallIntegerField(default=0, verbose_name = "#MP")
    # n_testplates = models.SmallIntegerField(default=0, verbose_name = "#TP")
    # n_assays = models.SmallIntegerField(default=0, verbose_name = "#Assays")
    # n_inhibitions = models.SmallIntegerField(default=0, verbose_name = "#Inhib")
    # n_mic = models.SmallIntegerField(default=0, verbose_name = "#MIC")
    # n_cc50 = models.SmallIntegerField(default=0, verbose_name = "#CC50")
    # n_hc50 = models.SmallIntegerField(default=0, verbose_name = "#HC50")
    # n_synmic = models.SmallIntegerField(default=0, verbose_name = "#synMIC")
    # screen_date = models.DateField(null=True, blank=True, verbose_name="Screen")

    #------------------------------------------------
    class Meta:
        app_label = 'dscreen'
        db_table = 'screen_run'
        ordering=['run_type','run_id']
        indexes = [
            models.Index(name="run_type_idx", fields=['run_type']),
        ]

    # #------------------------------------------------
    # def __str__(self) -> str:
    #     return f"{self.run_id}"

    #------------------------------------------------
    def __repr__(self) -> str:
        return f"{self.run_id} [{self.run_type}]"

    #------------------------------------------------
    @classmethod
    def get(cls,RunID,verbose=0):
        try:
            retInstance = cls.objects.get(run_id=RunID)
        except:
            if verbose:
                print(f"[Run_ID Not Found] {RunID} ")
            retInstance = None
        return(retInstance)

    #------------------------------------------------
    @classmethod
    def exists(cls,RunID,verbose=0):
        return cls.objects.filter(run_id=RunID.strip()).exists()
    
    #------------------------------------------------
    def update_summary(self):
        print('To be implemented')
        # self.n_compounds = 
        # self.n_qc = 
        # self.n_structure = 
        # self.n_motherplates = 
        # self.n_testplates = 
        # self.n_assays = 
        # self.n_inhibitions = 
        # self.n_mic = 
        # self.n_cc50 = 
        # self.n_hc50 = 
        # self.n_synmic = 
        # self.screen_date = 
           

#
# Assay (?)
# AssayData_MIC
# AssayData_CC50
# AssayData_HC50
# AssayData_SynMIC
# AssayData_SynIsobol
#
#